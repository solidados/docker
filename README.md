# Docker

## Entry
> Docker – это платформа для разработуи, доставки и запуска контейнерных приложений.

Позволяет:
- создавать контейнеры
- автоматизировать их запуск и развёртынвание
- управлять их жизненным циклом

Docker инкапсулирует в образе:
- Операционную систему
- среду запуска
- все конфигурации и настройки
- приложения
- и т.д.

## Важиные Концепции Docker
1. `Docker Images` (образы)
> образ – это своего рода чертёж для контейнера.

Он содержит такие элементы как:
- рабочая среда (например конкретная версия Node)
- код приложения
- зависимости (dependencies)
- конфигурации
- переменные среды (.env)
- команды (которые нужно запустить, чтобы приложение работало)

Образы так же имеют собственную файловую систему, которая не зависима от остальной части. Как только Образ был создан, то он уже не может быть изменён. И если требуется внести изменения, то необходимо создать совершенно новый образ, чтобы включить эти изменения.

2. `Docker Containers` (контейнеры)
> контейнеры - это исполняемые экземпляры созданных образов

Docker контейнер производит (изолированный процесс):
- запуск экземпяра образа
- запуск приложения
 
## VM vs. Container
Каждая созданная виртуальная машина, запускает свою собственную полноценную Операционную систему с собственным ядром, которое работает поверх операционной сисиемы рабочего компьютера. 

Контейнеры этого не делают! Они используют ядро ОС рабочего компьютера, поэтому они более лёгкие и менее ресурсо-затратные. Это так же означает, что они обычно быстрее запускаются и используют меньше памяти.  
Контейнеры включают в себя облегчённую версию конкретной ОСи, но они всё ещё используют ябро хост-машины в качестве основы. Так что контейнеры гораздо легче и быстрее `Virtual Machines`

## Docker Image (образ)
Образы состоят из нескольких слоёв, где каждый слой инкрементно добавляет что-то своё к каждому образу.

|     | Слои образов            |               |
| --- | ----------------------- | ------------- |
| 4   | Конфигурации            |               |
| 3   | Зависимости             |               |
| 2   | Код приложения          |               |
| 1   | Родительский образ (ОС) | (Node, Linux) |

Порядок слоёв имеет значение.  
1. Обычно, образ начинается с сущности, которая называется **родительским образом**. По сути, это и есть первы и основной слой. Этот слой описывает лёгкую ОС и рабочую среду контейнера. Можно создать контейнер с родительским образом, в котором будет установлена определённая версия `Node` на дистрибутиве `Linux`, и этот слой сам по себе уже представляет предварительно созданный **докер-образ**.  
2. Все последующие слои могут быть чем угодно

### Содание первого образа и его слоёв
1. Выполненная [Команда `docker pull node`](./commands.md/#команда-pull) загрузит последнюю официальную версию `Node` в начальный основной (Родительский) слой образа.  
2. Чтобы превратить проект в **докер-образ** в его корневой директории необходимо создать `Dockerfile`. По сути, это набор инструкций, которые сообщают `Docker` как создать образ со всеми своими различными слоями.  
Каждая инстуркция будет находитьс на отдельной строке внутри этого файла. Каждая инструкция в `Dockerfile` представляет собой разный слой в конечном образе.  
- Первой инструкцией будет первый слой `Node`, который был скачен с `docker-hub` - `FROM node:22-alpine` 
> `22-alpine` вместо `latest` - это дистрибутив Linux, который известен своим минимальным размером и ориентацией на безопасность
- Далее добавляется инструкция `WORKDIR` с указанием пути рабочего католога
- Следующим слоем добавляется инструкция для копирования кода приложения, который находится в папаке  `/api`
  + точка `.` – это относительный путь до папки с кодом (либо, если указана была `WORKDIR`, то путь нужно указывать так: `. .` – это означает, что код необходимо скопировать в корень рабочей директории `app`)
  + внутри образа будет создана папка `app`, куда будут скопированы все файлы проекта
- Следующий слой – это установка всех зависимостей, необходимых для работы приложения `RUN npm install`
- Следующая инструкция сообщает Docker, какой порт должен быть открыт для запуска приложения: `EXPOSE 3000`
- Завершающим слоем должна быть команда для запуска самого приложения. для этого есть команда `npm run dev`, которая определена в файле `package.json`. Но это не совсем верно, поэтому используется команда `CMD` перечисляющая команды, которые должны выполняться при запуске контейнера. То есть, когда установка будет произведена, эта команда запустит скрипт внутри контейнера: `CMD ["npm", "run", "dev"]`

## Получение доступа к контейнеру снаружи

## Layers caching
### Процесс оптимизации процесса сборки образа
Каждая строка, записанная в `Dockefile` представляет собой новый слой.
```dockerfile
# загрузка образа Node и версия оптимизации образа
FROM node:22-alpine

# указание рабочей директории. Эта инфо добавляется как слой в финальный образ
WORKDIR /app

# копирование исходных файлов на образ
COPY . .

# установка зависимостей... и так далее. 
RUN npm install

# каждая строка здесь представляет добавление новго слоя к образу.
```
При внесении каких-либо изменений в исходный код, необходимо пересобрать новый образ, чтобы подхватить эти изменения.  
Если этого не сделать, то контейнеры будут создавать на основе старого образа со старым кодом.
```shell
$ docker build -t <новое имя образа> .
```

> На этот раз создание должно занимать меньше времени, так как каждый раз, кода `Docker` пытается создать образ и проходит через разные слои, он сохраняет этот образ на каждом слое в `cache`. Другими словами, после каждого слоя, `Docker` берёт актуальное состояние образа и сохраняет его в `cache`.

Однако при иизменении кода, DOcker берёт из кэша только то, что было до изменённого слоя, а всё, что после –запускает снова, как например – `npm install` 

Но этот процесс так же можно оптимизировать, поменяв слой копирования (COPY) и установки (INSTALL) местами. В случае 
изменения исходного кода, слой установки будет браться из `cache`.

Однако есть нюанс: когда Docker доходит до слоя INSTALL, то `package.json` ещё отсутствует, так как он находится на слое COPY. Поэтому необходимо добавить слой, который будет копировать только один файл и помещать его в рабочую директорию.

> Больше информации о кэшировании слоёв и оптимизации сборки [читать документацию](https://docs.docker.com/build/cache/)
